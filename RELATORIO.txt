RELATÓRIO DO PIPELINE LLM + HEURÍSTICAS (Defects4J)
Data: 2026-01-12
SO: Windows (PowerShell) | Python: 3.11
Workspace: C:\Users\lucas\OneDrive\Área de Trabalho\TCC

1) Objetivo
- Extrair métodos Java de um repositório (base commons-lang) e priorizar trechos potencialmente bugados usando heurísticas inspiradas no Defects4J e, opcionalmente, uma LLM (Gemini).

2) Implementação
- Aquisição de dados: LLM_defects4j_TCC/data_acquisition.py
  * Correção: removido uso indevido de 'global git' e import redundante; uso de importlib para garantir import do GitPython após instalação.
  * Funções: clonar_repositorio_java(url, destino) e contar_arquivos_java(diretorio).

- Filtro de trechos: LLM_defects4j_TCC/bug_filter_llm.py
  * Componentes:
    - JavaSnippetExtractor: lista arquivos .java e extrai métodos (preferência javalang; fallback regex).
    - HeuristicBugDetector: regex/heurísticas (string '==', off-by-one (<= length), empty catch, swallowed exception, resource leak sem try-with-resources, equals sem null-check).
    - LLMFilter (Gemini): classifica trechos e retorna JSON com bug_likelihood, labels e reason; leitura automática de .env via python-dotenv; fallback de modelo quando indisponível.
    - FilterPipeline: integra extrator + heurísticas + LLM; ordena por score e retorna top_k.

- Runner: LLM_defects4j_TCC/run_filter.py
  * Lê REPO_PATH, OUT_PATH, USE_LLM do ambiente/.env; executa pipeline e salva JSON.

- Configuração e documentação:
  * LLM_defects4j_TCC/requirements.txt: GitPython, javalang, google-generativeai, python-dotenv.
  * LLM_defects4j_TCC/README.md: instruções de uso, obtenção de chave, exemplos de execução.
  * LLM_defects4j_TCC/.env.example: template de variáveis (GEMINI_API_KEY, GEMINI_MODEL, USE_LLM, REPO_PATH, OUT_PATH).
  * LLM_defects4j_TCC/.gitignore: ignora .env e artefatos.

3) Execução realizada
- Clone:
  * URL: https://github.com/apache/commons-lang.git
  * Destino: C:\Users\lucas\OneDrive\Área de Trabalho\TCC\dados\commons-lang
  * Contagem: 531 arquivos .java

- Filtro (heurísticas ativas, LLM opcional):
  * Comando (pasta do projeto):
    - python LLM_defects4j_TCC/run_filter.py
  * Saída JSON: C:\Users\lucas\OneDrive\Área de Trabalho\TCC\dados\bug_snippets.json
  * Resultado: 50 snippets salvos (geral). Com filtro de padrões:
    - PATTERNS = equals-without-null-check,string-equality-using-==
    - STRICT_FILTER = 0 (qualquer interseção)
    - TOP_K = 20
    - Resultado: 20 snippets salvos
  * Campo 'llm': nulo (LLM não contribuiu devido indisponibilidade de modelo/SDK), mas heurísticas funcionaram.

4) Resultados observados (amostra)
- Campos por item: file, name, heuristic_score, heuristic_labels, llm, score, labels, snippet.
- Padrões recorrentes (top):
  * equals-without-null-check
  * string-equality-using-==
  * swallowed-exception
- Exemplos do topo (resumo):
  * AnnotationUtils.equals: labels = equals-without-null-check, string-equality-using-==; score ≈ 0.4
  * BooleanUtils.toBoolean: labels = equals-without-null-check, string-equality-using-==; score ≈ 0.4
  * Range.equals: labels = equals-without-null-check, string-equality-using-==; score ≈ 0.4

5) Observações técnicas
- Gemini SDK: migrado de google-generativeai (deprecated) para google-genai (0.2.0+); integração completa no código com google.genai.Client e generate_content().
- Quota da API: Gemini API (chave configurada em .env) retornou erro 429 RESOURCE_EXHAUSTED. Limites do free tier excedidos (modelos testados: gemini-2.0-flash-exp, gemini-1.5-flash). Sistema opera com sucesso usando apenas heurísticas (USE_LLM=0). Campos 'llm' e 'llm_fix' ficam nulos até renovação de quota (24h) ou upgrade de plano.
- Caminhos relativos: ajustado REPO_PATH/OUT_PATH em .env para apontar para ../dados quando executando a partir de LLM_defects4j_TCC.
- Dotenv: ativado auto-carregamento de .env; necessário ter python-dotenv instalado.
- Filtro por padrões: adicionados controles via ambiente `PATTERNS` (labels alvo), `STRICT_FILTER` (interseção vs inclusão total) e `TOP_K`.
- FixSuggester: implementado sugestor de correções heurísticas para cada padrão detectado (ex: string-equality sugere .equals(), off-by-one sugere < length). Saídas em campo 'suggestion' do JSON.
- Export CSV: criado export_csv.py para converter JSON em planilha (colunas: file, class, method, score, labels, heuristic_fix, llm_fix). Facilita análise estatística e filtragem em ferramentas externas.

6) Como reproduzir
- Instalar dependências:
  - python -m pip install -r C:\Users\lucas\OneDrive\Área de Trabalho\TCC\LLM_defects4j_TCC\requirements.txt
- Clonar e contar:
  - python C:\Users\lucas\OneDrive\Área de Trabalho\TCC\LLM_defects4j_TCC\data_acquisition.py
- Rodar filtro:
  - (opcional) editar .env para REPO_PATH=../dados/commons-lang e OUT_PATH=../dados/bug_snippets.json
  - python C:\Users\lucas\OneDrive\Área de Trabalho\TCC\LLM_defects4j_TCC\run_filter.py
  - (filtrar por padrões)
    - PowerShell:
      $env:PATTERNS = "equals-without-null-check,string-equality-using-=="
      $env:STRICT_FILTER = "0"
      $env:TOP_K = "20"
      python C:\Users\lucas\OneDrive\Área de Trabalho\TCC\LLM_defects4j_TCC\run_filter.py

7) Próximos passos
- LLM: aguardar renovação de quota (24h do free tier) ou habilitar billing no Google AI Studio. Modelos gemini-2.0-flash-exp e gemini-1.5-flash estão configurados no código. Consultar TROUBLESHOOTING.txt para detalhes de resolução.
- Heurísticas: expandir com padrões específicos por projeto do Defects4J (hashCode/equals mismatch, indexOf/substring off-by-one, null pointer in collections, concurrent modification); calibrar scores.
- Avaliação Defects4J: criar script evaluate_defects4j.py para validação contra mapeamentos de bugs (arquivos/métodos alterados) e medir precision/recall/top-K.
- Fine-tuning: se disponível, treinar modelo Gemini com exemplos rotulados do Defects4J para melhorar classificação.

8) Arquivos entregues
- LLM_defects4j_TCC/data_acquisition.py: clonagem de repositórios com GitPython
- LLM_defects4j_TCC/bug_filter_llm.py: pipeline completo (extrator, detector, LLM, suggester)
- LLM_defects4j_TCC/run_filter.py: runner CLI com variáveis de ambiente
- LLM_defects4j_TCC/export_csv.py: conversor JSON → CSV
- LLM_defects4j_TCC/requirements.txt: dependências Python
- LLM_defects4j_TCC/.env.example: template de configuração
- LLM_defects4j_TCC/.gitignore: exclusão de artefatos e credenciais
- LLM_defects4j_TCC/README.md: documentação de uso completa
- LLM_defects4j_TCC/RELATORIO.txt: este relatório
- LLM_defects4j_TCC/TROUBLESHOOTING.txt: guia de resolução de problemas da API Gemini
- dados/bug_snippets.json: 20 snippets filtrados (padrões: equals-without-null-check + string-equality-using-==)
- dados/bug_snippets.csv: 50 snippets exportados para planilha

FIM
